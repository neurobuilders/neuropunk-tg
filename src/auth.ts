import NextAuth, { CredentialsSignin, NextAuthConfig } from "next-auth";
import env from "@/env";
import Credentials from "next-auth/providers/credentials";
import { createClient } from "@/helpers/supabase/server";
import { ExtendedUser } from "@/types/next-auth";
import { validateUser } from "@/helpers/user";
import { captureException } from "@/helpers/utils";

const cookiePrefix = "neuropunk_auth_";

class NotFoundUserError extends CredentialsSignin {
  code = "not-found-user";
}

export const config: NextAuthConfig = {
  secret: env.auth.secret,
  providers: [
    Credentials({
      id: "tg-miniapp",
      name: "Telegram Mini App",
      credentials: {},
      async authorize(data) {
        // console.log("> authorize req", data);
        const { initDataRaw } = data as { initDataRaw: string };
        let dbUser = null;
        try {
          const user = await validateUser(initDataRaw);
          const supabase = await createClient();

          const { data } = await supabase
            .from("users")
            .select()
            .eq("tg_id", user.id)
            .maybeSingle();

          dbUser = data;
        } catch (err) {
          captureException(err);
          return null;
        }

        if (dbUser) {
          // console.log("database user", dbUser);
          const {
            id,
            first_name,
            last_name,
            email,
            tg_id,
            tg_avatar_url,
            tg_language_code,
            is_tg_premium,
            created_at,
          } = dbUser;
          return {
            id,
            tgId: tg_id,
            firstName: first_name,
            lastName: last_name,
            name: [first_name, last_name || ""].filter(Boolean).join(" "),
            image: tg_avatar_url,
            //   languageCode: tg_language_code,
            //   isPremium: is_tg_premium,
            //   createdAt: created_at,
          };
        } else {
          throw new NotFoundUserError();
        }
      },
    }),
  ],
  callbacks: {
    async session(props) {
      //   console.log("> session", props);
      const { session, token } = props;
      const { id, tgId, firstName, lastName } = token;
      //   const loginCookie = await login(user.email, user.autogenerated_password);
      //   console.log("loginCookie", loginCookie);
      const user = session.user as unknown as ExtendedUser; // @todo
      user.id = id as string;
      user.tgId = tgId as string;
      user.firstName = firstName as string;
      user.lastName = lastName as string;
      return session;
    },
    // async signIn(props) {
    //   console.log("> signIn", props);
    //   return true;
    // },
    // async redirect(props) {
    //   console.log("> redirect", props);
    //   const { url, baseUrl } = props;
    //   // Allows relative callback URLs
    //   if (url.startsWith("/")) return `${baseUrl}${url}`;
    //   // Allows callback URLs on the same origin
    //   else if (new URL(url).origin === baseUrl) return url;
    //   return baseUrl;
    // },
    async jwt(props) {
      //   console.log("> jwt", props);
      const { token, user, account, profile, isNewUser } = props;
      return { ...token, ...user };
    },
  },
  // pages: {
  //   // signIn: "/auth/signin",
  //   // error: "/auth/error",
  //   newUser: "/auth/newUser",
  // },
  debug: !env.isProduction,
  useSecureCookies: true,
  cookies: {
    sessionToken: {
      name: `__Secure-next-auth.session-token`,
      options: {
        httpOnly: true,
        sameSite: "none",
        path: "/",
        secure: true,
        partitioned: true,
      },
    },
    callbackUrl: {
      name: `__Secure-authjs.callback-url`,
      options: {
        sameSite: "none",
        path: "/",
        secure: true,
        partitioned: true,
      },
    },
    csrfToken: {
      name: `__Host-authjs.csrf-token`,
      options: {
        httpOnly: true,
        sameSite: "none",
        path: "/",
        secure: true,
        partitioned: true,
      },
    },
    pkceCodeVerifier: {
      name: `${cookiePrefix}authjs.pkce.code_verifier`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: true,
        maxAge: 900,
      },
    },
    state: {
      name: `${cookiePrefix}authjs.state`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: true,
        maxAge: 900,
      },
    },
    nonce: {
      name: `${cookiePrefix}authjs.nonce`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: true,
      },
    },
  },
  //   cookies: {
  //     sessionToken: {
  //       name: `${cookiePrefix}session-token`,
  //       options: {
  //         httpOnly: true,
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //       },
  //     },
  //     callbackUrl: {
  //       name: `${cookiePrefix}callback-url`,
  //       options: {
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //       },
  //     },
  //     csrfToken: {
  //       name: `${cookiePrefix}csrf-token`,
  //       options: {
  //         httpOnly: true,
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //       },
  //     },
  //     pkceCodeVerifier: {
  //       name: `${cookiePrefix}pkce-code-verifier`,
  //       options: {
  //         httpOnly: true,
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //         maxAge: 900,
  //       },
  //     },
  //     state: {
  //       name: `${cookiePrefix}state`,
  //       options: {
  //         httpOnly: true,
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //         maxAge: 900,
  //       },
  //     },
  //     nonce: {
  //       name: `${cookiePrefix}nonce`,
  //       options: {
  //         httpOnly: true,
  //         sameSite: "lax",
  //         path: "/",
  //         secure: true,
  //       },
  //     },
  //   },
};

export const { auth, handlers, signIn, signOut } = NextAuth(config);
